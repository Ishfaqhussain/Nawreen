<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Nawreen’s Go-To Page</title>
<link href="https://fonts.googleapis.com/css2?family=Pacifico&family=Nunito:wght@300;600&display=swap" rel="stylesheet">
<style>
  :root{
    --accent-pink: #ff4fa8;
    --accent-light: #ffd6ea;
    --glass: rgba(255,255,255,0.08);
  }

  html,body{
    height:100%;
    margin:0;
    font-family: 'Nunito', sans-serif;
    background: radial-gradient(circle at 25% 20%, #0d0128 0%, #03010f 55%, #000 100%);
    color:#fff;
    overflow:hidden;
  }

  /* Canvas behind UI; pointer-events none so UI clickable */
  canvas#canvas {
    position: fixed;
    inset: 0;
    width: 100%;
    height: 100%;
    z-index: 0;
    pointer-events: none;
    display:block;
  }

  /* soft pink glow behind heart */
  .heart-glow {
    position: fixed;
    left: 50%;
    top: 50%;
    transform: translate(-50%,-48%);
    width: 560px;
    height: 560px;
    border-radius: 50%;
    background: radial-gradient(circle, rgba(255,120,170,0.38) 0%, rgba(255,60,140,0.12) 30%, rgba(255,20,120,0.04) 60%, transparent 80%);
    filter: blur(36px) saturate(1.05);
    z-index: 1;
    pointer-events: none;
  }

  /* UI overlay */
  .ui {
    position: fixed;
    inset: 0;
    z-index: 4;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: flex-start;
    pointer-events: none; /* children override */
    text-align: center;
  }

  header.site-header {
    width:100%;
    padding: 18px 12px;
    box-sizing: border-box;
    font-family: 'Pacifico', cursive;
    font-size: 28px;
    color: var(--accent-light);
    text-shadow: 0 0 14px rgba(255,110,170,0.9);
    pointer-events: auto;
    text-align: center;
  }

  /* Main spacer to center heart vertically */
  .center-area {
    margin-top: 28px;
    width:100%;
    display:flex;
    flex-direction:column;
    align-items:center;
    justify-content:center;
    gap:14px;
    pointer-events: none;
  }

  /* Name inside the heart (handwritten) */
  .heart-name {
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%,-50%);
    z-index: 5;
    font-family: 'Pacifico', cursive;
    font-size: 44px;
    color: #fff;
    text-shadow: 0 0 20px rgba(255,120,180,0.95), 0 0 36px rgba(255,60,140,0.6);
    pointer-events: none;
    animation: pulseName 3.2s ease-in-out infinite;
  }
  @keyframes pulseName {
    0%{ transform: translate(-50%,-50%) scale(1); }
    50%{ transform: translate(-50%,-50%) scale(1.06); }
    100%{ transform: translate(-50%,-50%) scale(1); }
  }

  /* Subtitle below heart */
  .subtitle {
    font-size: 20px;
    color: #ffd6ea;
    text-shadow: 0 0 8px rgba(255,90,150,0.5);
    margin-top: 16px;
    pointer-events: auto;
  }

  /* footer area for reveal button */
  footer.site-footer {
    position: fixed;
    bottom: 22px;
    left: 0;
    right:0;
    display:flex;
    justify-content:center;
    pointer-events: auto;
    z-index: 6;
  }

  .reveal-btn {
    padding: 14px 28px;
    font-size: 16px;
    border-radius: 12px;
    background: rgba(255,255,255,0.08);
    border: 1px solid rgba(255,255,255,0.12);
    color: #fff;
    cursor: pointer;
    backdrop-filter: blur(6px);
    box-shadow: 0 10px 30px rgba(0,0,0,0.45);
    transition: transform .15s ease, opacity .25s ease;
  }
  .reveal-btn:active { transform: translateY(2px) scale(.995); }

  .message {
    position: fixed;
    bottom: 86px;
    left:50%;
    transform: translateX(-50%);
    font-size: 26px;
    font-weight: 700;
    opacity: 0;
    text-shadow: 0 0 18px rgba(255,140,200,0.9);
    transition: all .7s ease;
    z-index:6;
    pointer-events:none;
  }
  .message.show { opacity:1; transform: translateX(-50%) translateY(0); }

  /* small sparkles */
  .sparkle {
    position: fixed;
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: radial-gradient(circle,#fff, var(--accent-pink));
    filter: blur(.6px) drop-shadow(0 0 8px rgba(255,100,180,0.9));
    z-index: 6;
    pointer-events: none;
    animation: sparkleAnim 1s cubic-bezier(.2,.9,.2,1) forwards;
  }
  @keyframes sparkleAnim {
    0% { opacity: 1; transform: scale(.6) translateY(0); }
    100% { opacity: 0; transform: scale(2.2) translateY(-26px); }
  }

  /* butterfly base */
  .butterfly {
    position: fixed;
    width: 44px;
    height: 30px;
    pointer-events: none;
    z-index:6;
    transform-origin: center;
    filter: drop-shadow(0 8px 16px rgba(0,0,0,0.35));
  }

  @media (max-width:520px){
    header.site-header { font-size: 20px; padding:12px 8px; }
    .heart-name { font-size: 32px; }
    .subtitle { font-size: 16px; }
    .message { font-size: 20px; bottom: 80px; }
    .reveal-btn { padding: 10px 18px; font-size:15px; }
  }
</style>
</head>
<body>

  <!-- WebGL canvas -->
  <canvas id="canvas"></canvas>

  <!-- Pink glow behind heart -->
  <div class="heart-glow" aria-hidden="true"></div>

  <!-- UI overlay -->
  <div class="ui" aria-hidden="false">
    <header class="site-header">Nawreen’s Go To Page</header>

    <div class="center-area" role="main" aria-label="Main">
      <!-- heart area is the canvas; we place name absolutely on top -->
      <div style="width:360px; height:360px; position:relative; pointer-events:none;">
        <!-- name centered inside heart -->
        <div class="heart-name" aria-hidden="true">Nawreen</div>
      </div>

      <!-- subtitle below heart -->
      <div class="subtitle">You deserve love.</div>
    </div>

    <!-- message (hidden until reveal) -->
    <div id="message" class="message" role="status" aria-live="polite">THANK YOU FOR EXISTING</div>

    <!-- footer reveal button -->
    <footer class="site-footer">
      <button id="revealBtn" class="reveal-btn" aria-pressed="false">Tap to Reveal Today’s Message</button>
    </footer>
  </div>

  <!-- calm music (play on reveal click) -->
  <audio id="bgm" preload="auto" loop>
    <source src="https://cdn.pixabay.com/download/audio/2022/03/15/audio_3b637dc5d0.mp3?filename=snowfall-ambient-piano-21076.mp3" type="audio/mpeg">
  </audio>

<script>
/* ====== UI: reveal, sparkles, butterflies, music ====== */
const revealBtn = document.getElementById('revealBtn');
const messageEl = document.getElementById('message');
const bgm = document.getElementById('bgm');

function spawnSparkles(centerX, centerY, count=18) {
  for(let i=0;i<count;i++){
    const s = document.createElement('div');
    s.className = 'sparkle';
    s.style.left = (centerX + (Math.random()-0.5) * 220) + 'px';
    s.style.top  = (centerY + (Math.random()-0.5) * 160) + 'px';
    s.style.width = (6 + Math.random()*8) + 'px';
    s.style.height = s.style.width;
    s.style.animationDuration = (0.9 + Math.random()*0.6) + 's';
    document.body.appendChild(s);
    setTimeout(()=> s.remove(), 1200);
  }
}

function createButterfly(x,y,dur=6,delay=0,scale=1,flip=false){
  const el = document.createElement('div');
  el.className = 'butterfly';
  el.style.left = x + 'px';
  el.style.top = y + 'px';
  el.style.transform = `scale(${scale}) ${flip? 'rotateY(180deg)' : ''}`;
  const anim = 'fly' + Math.floor(Math.random()*1e6);
  const dx = (Math.random()*240 + 120) * (Math.random()<0.5 ? 1 : -1);
  const dy = - (Math.random()*260 + 180);
  const rot = (Math.random()*50 - 20);
  const style = document.createElement('style');
  style.innerHTML = `
    @keyframes ${anim} {
      0% { transform: translate(0,0) scale(${scale}) rotate(${rot}deg); opacity:0; }
      6% { opacity:1; }
      60% { transform: translate(${dx*0.5}px, ${dy*0.55}px) scale(${scale}) rotate(${rot+10}deg); }
      100% { transform: translate(${dx}px, ${dy}px) scale(${scale}) rotate(${rot+30}deg); opacity:0.95; }
    }`;
  document.head.appendChild(style);

  el.innerHTML = `<svg viewBox="0 0 64 48" xmlns="http://www.w3.org/2000/svg">
    <g transform="translate(32,24)">
      <path d="M0 -2 C18 -30 45 -26 38 -6 C30 12 2 4 0 -2 Z" fill="#ff8ad7"/>
      <path d="M0 2 C-18 30 -45 26 -38 6 C-30 -12 -2 -4 0 2 Z" fill="#ffd1ea"/>
    </g>
  </svg>`;

  el.style.animation = `${anim} ${dur}s ${delay}s linear forwards`;
  document.body.appendChild(el);
  setTimeout(()=> { el.remove(); style.remove(); }, (delay + dur + 0.4)*1000);
}

function onReveal(e){
  // vanish button
  revealBtn.disabled = true;
  revealBtn.style.transition = 'opacity .35s ease, transform .35s ease';
  revealBtn.style.opacity = 0;
  revealBtn.style.transform = 'scale(.92) translateY(6px)';
  setTimeout(()=> revealBtn.remove(), 380);

  // show message
  setTimeout(()=> { messageEl.classList.add('show'); }, 260);

  // particle burst
  const rect = e.currentTarget.getBoundingClientRect();
  const cx = rect.left + rect.width/2;
  const cy = rect.top + rect.height/2;
  spawnSparkles(cx, cy, 22);

  // butterflies celebration
  for(let i=0;i<6;i++){
    createButterfly(Math.random()*window.innerWidth, window.innerHeight*0.9, 5+Math.random()*3, i*0.08, 0.7+Math.random()*0.7, Math.random()<0.5);
  }

  // play music (user interaction allows play)
  bgm.play().catch(()=>{});
}
revealBtn.addEventListener('click', onReveal);
revealBtn.addEventListener('keydown', (ev)=> { if(ev.key==='Enter' || ev.key===' ') { ev.preventDefault(); onReveal(ev); } });

/* ====== WebGL heart shader (original shader code retained) ====== */
const canvas = document.getElementById('canvas');
const gl = canvas.getContext('webgl');
if(!gl) { console.error('WebGL not supported'); }

function resize(){
  const dpr = window.devicePixelRatio || 1;
  const w = Math.floor(window.innerWidth * dpr);
  const h = Math.floor(window.innerHeight * dpr);
  if(canvas.width !== w || canvas.height !== h){
    canvas.width = w;
    canvas.height = h;
    canvas.style.width = window.innerWidth + 'px';
    canvas.style.height = window.innerHeight + 'px';
    gl.viewport(0,0,canvas.width,canvas.height);
  }
}
window.addEventListener('resize', resize);
resize();

/* vertex shader */
const vertSrc = `
attribute vec2 position;
void main(){ gl_Position = vec4(position, 0.0, 1.0); }
`;

/* fragment shader - the heart shader you provided originally */
const fragSrc = `
precision highp float;
uniform float width;
uniform float height;
uniform float time;
vec2 resolution = vec2(width, height);

#define POINT_COUNT 8
vec2 points[POINT_COUNT];
const float speed = -0.5;
const float len = 0.25;
float intensity = 1.3;
float radius = 0.008;

float sdBezier(vec2 pos, vec2 A, vec2 B, vec2 C){
    vec2 a = B - A;
    vec2 b = A - 2.0*B + C;
    vec2 c = a * 2.0;
    vec2 d = A - pos;

    float kk = 1.0 / dot(b,b);
    float kx = kk * dot(a,b);
    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;
    float kz = kk * dot(d,a);

    float res = 0.0;

    float p = ky - kx*kx;
    float p3 = p*p*p;
    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;
    float h = q*q + 4.0*p3;

    if(h >= 0.0){ 
        h = sqrt(h);
        vec2 x = (vec2(h, -h) - q) / 2.0;
        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));
        float t = uv.x + uv.y - kx;
        t = clamp( t, 0.0, 1.0 );

        vec2 qos = d + (c + b*t)*t;
        res = length(qos);
    }else{
        float z = sqrt(-p);
        float v = acos( q/(p*z*2.0) ) / 3.0;
        float m = cos(v);
        float n = sin(v)*1.732050808;
        vec3 t = vec3(m + m, -n - m, n - m) * z - kx;
        t = clamp( t, 0.0, 1.0 );

        vec2 qos = d + (c + b*t.x)*t.x;
        float dis = dot(qos,qos);
        res = dis;

        qos = d + (c + b*t.y)*t.y;
        dis = dot(qos,qos);
        res = min(res,dis);

        qos = d + (c + b*t.z)*t.z;
        dis = dot(qos,qos);
        res = min(res,dis);

        res = sqrt( res );
    }
    
    return res;
}

vec2 getHeartPosition(float t){
    return vec2(16.0 * sin(t) * sin(t) * sin(t),
                            -(13.0 * cos(t) - 5.0 * cos(2.0*t)
                            - 2.0 * cos(3.0*t) - cos(4.0*t)));
}

float getGlow(float dist, float radius, float intensity){
    return pow(radius/dist, intensity);
}

float getSegment(float t, vec2 pos, float offset, float scale){
    for(int i = 0; i < POINT_COUNT; i++){
        points[i] = getHeartPosition(offset + float(i)*len + fract(speed * t) * 6.28);
    }
    
    vec2 c = (points[0] + points[1]) / 2.0;
    vec2 c_prev;
    float dist = 10000.0;
    
    for(int i = 0; i < POINT_COUNT-1; i++){
        c_prev = c;
        c = (points[i] + points[i+1]) / 2.0;
        dist = min(dist, sdBezier(pos, scale * c_prev, scale * points[i], scale * c));
    }
    return max(0.0, dist);
}

void main(){
    vec2 uv = gl_FragCoord.xy/resolution.xy;
    float widthHeightRatio = resolution.x/resolution.y;
    vec2 centre = vec2(0.5, 0.5);
    vec2 pos = centre - uv;
    pos.y /= widthHeightRatio;
    pos.y += 0.02;
    float scale = 0.000015 * height;
    float t = time;
    
    float dist = getSegment(t, pos, 0.0, scale);
    float glow = getGlow(dist, radius, intensity);
    
    vec3 col = vec3(0.0);

    col += 10.0*vec3(smoothstep(0.003, 0.001, dist));
    col += glow * vec3(1.0,0.05,0.3);
    
    dist = getSegment(t, pos, 3.4, scale);
    glow = getGlow(dist, radius, intensity);
    
    col += 10.0*vec3(smoothstep(0.003, 0.001, dist));
    col += glow * vec3(0.1,0.4,1.0);
          
    col = 1.0 - exp(-col);
    col = pow(col, vec3(0.4545));

    gl_FragColor = vec4(col,1.0);
}
`;

/* compile helpers */
function compile(src,type){
  const s = gl.createShader(type);
  gl.shaderSource(s, src);
  gl.compileShader(s);
  if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)){
    console.error(gl.getShaderInfoLog(s));
  }
  return s;
}

const v = compile(vertSrc, gl.VERTEX_SHADER);
const f = compile(fragSrc, gl.FRAGMENT_SHADER);
const program = gl.createProgram();
gl.attachShader(program, v);
gl.attachShader(program, f);
gl.linkProgram(program);
gl.useProgram(program);

/* vertex buffer */
const vertexData = new Float32Array([-1,1, -1,-1, 1,1, 1,-1]);
const buf = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buf);
gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.STATIC_DRAW);

const posAttrib = gl.getAttribLocation(program,'position');
gl.enableVertexAttribArray(posAttrib);
gl.vertexAttribPointer(posAttrib, 2, gl.FLOAT, false, 0, 0);

/* uniforms */
const timeLoc = gl.getUniformLocation(program,'time');
const widthLoc = gl.getUniformLocation(program,'width');
const heightLoc = gl.getUniformLocation(program,'height');

let start = performance.now();
function frame(now){
  resize();
  const t = (now - start) / 1000;
  gl.uniform1f(timeLoc, t);
  gl.uniform1f(widthLoc, canvas.width);
  gl.uniform1f(heightLoc, canvas.height);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  requestAnimationFrame(frame);
}
requestAnimationFrame(frame);

</script>
</body>
</html>
